#pragma once
#include "core/optix_global.h"
#include <iostream>
#include <vector>
using namespace std;

static RT_FUNCTION int beckers(const float3 &v) {

	if (v.z <= 0.0)
		return 0;

	//int nRings = 8; //145
	//int nRings   = 15; //550
	int nRings = 30; //2200

	//int nRings = 9; //klems

	//int nRings = 8;
	//int nRings = 41;
	//int nRings = 11;
	//int nRings = 57;


	//int rings[] = { 1, 7, 12, 18, 22, 26, 29, 30 }; //145
	//int rings[] = { 1,8,13,20,25,31,36,41,45,49,52,55,57,58,59 }; //550
	int rings[] = { 1, 6, 12, 18, 24, 30, 36, 42, 48, 54, 59, 65, 70, 75, 79, 84, 88, 92, 96, 99, 103, 106, 108, 111, 113, 114, 115, 117, 117, 118 }; //2200
	//int rings[] = { 1, 8, 16, 20, 24, 24, 24, 16, 12 }; //klems

	//int rings[] = { 1, 4, 11, 16, 19, 21 };
	// int rings[] = { 1, 6, 12, 18, 22, 26, 29, 30 };
	//int rings[]      = { 1, 8, 13, 19, 24, 29, 34, 37, 40, 41, 42 };
	//int rings[] = { 1, 3, 10, 16, 23, 29, 35, 41, 47, 53, 59, 65, 70, 76, 82, 87, 92, 97, 102, 107, 111, 116, 120, 124, 128, 132, 135, 138, 142, 144,147,149,152,154,155,157,158,159,160,160,160 };
	//int ringsacum[] = { 1, 4, 14, 30, 53, 82, 117, 158, 205, 258, 317, 382, 452, 528, 610, 697, 789, 886, 988, 1095, 1206, 1322, 1442, 1566, 1694, 1826, 1961, 2099, 2241, 2385, 2532,2681,2833,2987,3142,3299,3457,3616,3776,3936,4096 };
	//int ringsacum[]  = { 1, 9, 22, 41, 65, 94, 128, 165, 205, 246, 288 };
	//int ringsacum[] = { 1, 7, 19, 37, 59, 85, 114, 144 };
	//int ringsacum[] = { 1, 5, 16, 32, 51, 72 };
	//int ringsacum[] = { 1, 8, 20, 38, 60, 86, 115, 145 }; //145
	//int ringsacum[] = { 1, 9, 22, 42, 67, 98, 134, 175, 220, 269, 321, 376, 433, 491, 550 }; //550
	int ringsacum[] = { 1, 7, 19, 37, 61, 91, 127, 169, 217, 271, 330, 395, 465, 540, 619, 703, 791, 883, 979, 1078, 1181, 1287 , 1395, 1506, 1619, 1733, 1848, 1965, 2082, 2200}; //2200
	//int ringsacum[] = { 1, 9, 25, 45, 69, 93, 117, 133, 145 }; //klems

	//float ringslat[] = { 0.0822, 0.3874, 0.6850, 0.9799, 1.2754, 1.5708 };
	//float ringslat[] = { 0.1044, 0.3137, 0.5246, 0.7336, 0.9433, 1.1529, 1.3619, 1.5708 };
	//float ringslat[] = { 0.1001, 0.2438, 0.3904, 0.5374, 0.6851, 0.8330, 0.9806, 1.1281, 1.2755, 1.4231, 1.5708 };
	//float ringslat[] = { 0.0049, 0.0434, 0.0825, 0.1219, 0.1611, 0.2002, 0.2393, 0.2785, 0.3176, 0.3568, 0.3959, 0.4351, 0.4742, 0.5134, 0.5526, 0.5917, 0.6309, 0.6700, 0.7092, 0.7483, 0.7875, 0.8266, 0.8658, 0.9050, 0.9441, 0.9833, 1.0225, 1.0616, 1.1008, 1.1400, 1.1791, 1.2183, 1.2575, 1.2966, 1.3358, 1.3750,
	//	1.4141,1.4533,1.4925,1.5316,1.5708 };

	//float ringslat[] = { 0.1212, 0.3224, 0.5301, 0.7373, 0.9458, 1.154, 1.362, 1.570 }; //145
	//float ringslat[] = { 0.0732, 0.1786, 0.2865, 0.3933, 0.5006, 0.6078, 0.7149, 0.8220, 0.9291, 1.0361, 1.1431, 1.2501, 1.3570 , 1.4639, 1.5708 }; //550
	float ringslat[] = { 0.0252, 0.0764, 0.1287, 0.1815, 0.2346, 0.2879, 0.3413, 0.3948, 0.4483, 0.5018, 0.5552, 0.6087, 0.6621, 0.7156, 0.7690, 0.8224, 0.8759, 0.9294, 0.9828, 1.0363, 1.0898, 1.1432, 1.1967, 1.2501, 1.3036, 1.3570, 1.4105, 1.4639, 1.5174, 1.5708 }; //2200
	//float ringslat[] = { 0.087266462, 0.26179938, 0.43633231, 0.6108652, 0.7853981, 0.9599310, 1.13446401, 1.3089969, 1.5707963 }; //klems


	//float azim = atan2(v.y, v.x);
	float azim = atan2(-v.x, -v.y);
	if (azim < 0)
		azim = 2 * M_PIf + azim;
	float zenit = atan2(sqrt(v.x*v.x + v.y*v.y), v.z);
	int l = 0;
	int r = nRings - 1;
	int mid = (int)floorf((l + r) / 2);
	while (l < r) {
		if (zenit > ringslat[mid])
			l = mid + 1;
		else if (zenit < ringslat[mid])
			r = mid;
		else
			break;
		mid = (int)floorf((l + r) / 2);
	}
	int ringid = mid;

	int patch;
	if (ringid == 0)
		patch = 1;
	else {
		float anglestep = 2 * M_PIf / rings[ringid];
		//cuidado aqui con overflow
		azim = azim + anglestep / 2.0f;
		if (azim > 2 * M_PIf)
			azim = azim - 2 * M_PIf;
		int ringint = (int)ceil(azim / anglestep);

		patch = ringsacum[ringid - 1] + ringint;
	}


	return patch;

}

